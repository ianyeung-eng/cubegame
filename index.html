<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Micro:bit 3D ç«‹æ–¹é«”æ§åˆ¶éŠæˆ²</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background: #ffffff; margin: 0; color: black; }
        #gameArea { width: 100vw; height: 80vh; }
        button { padding: 10px 20px; margin: 10px; background: #4CAF50; color: white; border: none; cursor: pointer; }
        button:hover { background: #45a049; }
        #status { color: #00008b; margin: 10px; }
        #score { font-size: 20px; margin: 10px; }
        #hp { font-size: 20px; margin: 10px; color: red; font-weight: bold; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 30px; color: red; display: none; z-index: 10; }
        #infoPanel { 
            position: fixed; right: 20px; top: 120px; width: 280px; background: rgba(255,255,255,0.95); 
            padding: 15px; border: 2px solid #333; border-radius: 10px; font-size: 14px; z-index: 100; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #infoPanel h3 { margin-top: 0; color: #333; }
        #infoPanel div { margin-bottom: 15px; padding: 10px; border-left: 4px solid #007bff; background: #f8f9fa; }
        #infoPanel img { float: left; margin: 0 10px 5px 0; border-radius: 5px; }
    </style>
</head>
<body>
    <h1>Micro:bit 3D ç«‹æ–¹é«”æ§åˆ¶éŠæˆ²</h1>
    <p>é€£æ¥ micro:bit å¾Œï¼Œå‚¾æ–œ micro:bit æ§åˆ¶ç«‹æ–¹é«”å‰å¾Œå·¦å³ç§»å‹•ï¼Œèº²é¿ä¾†è‡ªå››æ–¹çš„ä¸‰è§’éŒé«”ã€å¿«é€Ÿçƒé«”èˆ‡è®Šè‰²åŠ é€Ÿéšœç¤™ç‰©ï¼<br>æˆ–ä½¿ç”¨éµç›¤ä¸Šä¸‹å·¦å³éµæ§åˆ¶ã€‚<br><span style="color:red;">å°å¿ƒç¶ è‰²é‚Šç·£ï¼</span></p>

    <!-- éŠæˆ²å€åŸŸ -->
    <div id="gameArea"></div>
    <div id="gameOver">Game Over!</div>

    <!-- è¨ˆåˆ† & è¡€é‡ -->
    <div id="score">åˆ†æ•¸: 0</div>
    <div id="hp">è¡€é‡: 100/100</div>

    <!-- æ§åˆ¶æŒ‰éˆ• -->
    <button id="startBtn">é–‹å§‹éŠæˆ²</button>
    <button id="connectBtn">é€£æ¥ micro:bit</button>
    <button id="disconnectBtn" disabled>æ–·é–‹é€£æ¥</button>
    <div id="status">ç‹€æ…‹ï¼šæœªé€£æ¥</div>

    <!-- å³æ–¹éšœç¤™ç‰©ä»‹ç´¹é¢æ¿ -->
    <div id="infoPanel">
        <h3>ğŸ›‘ éšœç¤™ç‰©ä»‹ç´¹</h3>
        <div>
            <img src="https://airquee.com/wp-content/uploads/2021/09/Blue-Paintball-Obstacle-Pyramid-1-300x225.png" width="80" height="60" alt="è—è‰²ä¸‰è§’éŒ">
            <b>è—è‰²ä¸‰è§’éŒ</b><br>
            é€Ÿåº¦: 0.013<br>
            æ¯ 1 ç§’å‡ºç¾ä¸€æ¬¡ï¼Œå¾å››æ–¹è¡ä¾†ï¼
        </div>
        <div>
            <img src="https://m.media-amazon.com/images/I/61cS3atmRLL.jpg" width="80" height="60" alt="æ©™è‰²çƒé«”">
            <b>æ©™è‰²çƒé«”</b><br>
            é€Ÿåº¦: 0.075<br>
            æœ‰ 1.5 ç§’ç´…ç·šé è­¦ï¼Œè¶…å¿«è¡åˆºï¼
        </div>
        <div>
            <img src="https://res.cloudinary.com/skyhighpartyrentals/image/upload/f_auto,c_auto,w_766,h_450/media/catalog/product/5/0/50ft-obstacle-bounce-house_1.jpg" width="80" height="60" alt="é»ƒè‰²åœ“æŸ±">
            <b>é»ƒè‰² â†’ æ©™è‰²åœ“æŸ±</b><br>
            åˆå§‹é»ƒè‰²é€Ÿåº¦: 0.013<br>
            0.5 ç§’å¾Œè®Šæ©™è‰²åŠ é€Ÿè‡³ 0.0225ï¼
        </div>
    </div>

    <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // å…¨åŸŸè®Šæ•¸
    let device, server, service, txCharacteristic, rxCharacteristic;
    let gameRunning = false;
    let score = 0;
    let hp = 100;
    let maxHp = 100;
    let gameOver = false;
    let scene, camera, renderer;
    let cube, cubeHitbox;
    let obstacleHitboxes = [], sphereHitboxes = [], yellowHitboxes = [];
    let obstacles = [], sphereObstacles = [], yellowObstacles = [];
    let lines = [];
    let dx = 0, dz = 0;
    const maxSpeed = 0.05;
    const coneSpeed = 0.013;
    const sphereSpeed = 0.075;
    const yellowSpeed = 0.013;
    const OBJECT_SCALE = 0.4;
    const CUBE_SCALE = 0.6;
    const HITBOX_SCALE = 0.6;
    const SAFE_ZONE = 4.0; // å®‰å…¨å€é‚Šç•Œ
    const MAX_ZONE = 5.5; // æœ€å¤§é‚Šç•Œ (é˜²æ­¢é£›è„«)
    const GENERATE_OFFSET = 1.2; // ç”Ÿæˆå¤–ç§»è·é›¢ (2è§’è‰²é•·åº¦)
    const GENERATE_EDGE = 5 + GENERATE_OFFSET; // ç”Ÿæˆé‚Šç•Œ

    // è¡€é‡ç³»çµ±è®Šæ•¸
    let hpEl, scoreEl, statusEl, gameOverEl;
    let inEdgeZone = false;
    let damageInterval = null;
    let recoverInterval = null;
    let leftEdgeTime = 0;

    // éµç›¤æ§åˆ¶
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
    let keyDx = 0, keyDz = 0;

    // DOM å…ƒç´ 
    hpEl = document.getElementById('hp');
    scoreEl = document.getElementById('score');
    statusEl = document.getElementById('status');
    gameOverEl = document.getElementById('gameOver');
    const startBtn = document.getElementById('startBtn');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');

    // Web Bluetooth UART UUIDs
    const UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
    const UART_TX_CHARACTERISTIC_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
    const UART_RX_CHARACTERISTIC_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";

    // æ›´æ–°è¡€é‡é¡¯ç¤º
    function updateHp() {
        hpEl.textContent = `è¡€é‡: ${hp}/${maxHp}`;
    }

    // æ‰£è¡€é‚è¼¯
    function startDamage() {
        if (!damageInterval) {
            damageInterval = setInterval(() => {
                hp = Math.max(0, hp - 5);
                updateHp();
                if (hp <= 0) endGame('è¡€é‡è€—ç›¡ï¼');
            }, 500);
        }
    }

    // å›å¾©è¡€é‡é‚è¼¯
    function startRecover() {
        if (!recoverInterval) {
            recoverInterval = setInterval(() => {
                hp = Math.min(maxHp, hp + 5);
                updateHp();
            }, 1000);
        }
    }

    // åœæ­¢æ‰£è¡€/å›å¾©
    function stopDamage() {
        clearInterval(damageInterval);
        damageInterval = null;
    }

    function stopRecover() {
        clearInterval(recoverInterval);
        recoverInterval = null;
    }

    // Hitbox å‡½æ•¸ (ä¸è®Š)
    function createHitboxForObject(mesh, color = 0xffff00, scale = 1.0, isWireframe = true) {
        const size = new THREE.Vector3();
        new THREE.Box3().setFromObject(mesh).getSize(size);
        const hitboxGeometry = new THREE.BoxGeometry(size.x * scale, size.y * scale, size.z * scale);
        const hitboxMaterial = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4, wireframe: isWireframe });
        const hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
        hitbox.position.copy(mesh.position);
        hitbox.rotation.copy(mesh.rotation);
        return hitbox;
    }

    // ç«‹æ–¹é«” Hitbox
    function createCubeHitbox() {
        const scaledSize = 0.5 * CUBE_SCALE * HITBOX_SCALE;
        const hitboxGeometry = new THREE.BoxGeometry(scaledSize, scaledSize, scaledSize);
        const hitboxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.4, wireframe: true });
        cubeHitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
        cubeHitbox.position.copy(cube.position);
        scene.add(cubeHitbox);
    }

    // ä¸‰è§’éŒ Hitbox
    function createConeHitbox(cone) {
        const hitbox = createHitboxForObject(cone, 0x0000ff, 0.9);
        scene.add(hitbox);
        obstacleHitboxes.push(hitbox);
    }

    // çƒé«” Hitbox
    function createSphereHitbox(sphere) {
        const hitbox = createHitboxForObject(sphere, 0xffa500, 0.9);
        scene.add(hitbox);
        sphereHitboxes.push(hitbox);
    }

    // é»ƒè‰²è®Šæ©™è‰² Hitbox
    function createYellowHitbox(yellow) {
        const hitbox = createHitboxForObject(yellow, 0xffff00, 0.9);
        scene.add(hitbox);
        yellowHitboxes.push(hitbox);
    }

    // åˆå§‹åŒ– 3D å ´æ™¯
    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight * 0.8);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('gameArea').appendChild(renderer.domElement);

        // ç‡ˆå…‰
        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 5, 5);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // ç«‹æ–¹é«”
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true;
        cube.receiveShadow = true;
        cube.position.set(0, 0, 0);
        cube.scale.set(CUBE_SCALE, CUBE_SCALE, CUBE_SCALE);
        scene.add(cube);

        createCubeHitbox();

        // ç¶ è‰²å¹³å°
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -0.25;
        plane.receiveShadow = true;
        scene.add(plane);

        // ä¿¯è¦–ç›¸æ©Ÿ
        camera.position.set(0, 8, 6);
        camera.lookAt(0, 0, 0);

        animate();
    }

    // å‹•ç•«è¿´åœˆ
    function animate() {
        requestAnimationFrame(animate);
        if (gameRunning && !gameOver) {
            updateCubePositionAndRotation();
            updateObstacles();
            updateSphereObstacles();
            updateYellowObstacles();
            checkEdgeDamage();
        }
        renderer.render(scene, camera);
    }

    // æª¢æŸ¥é‚Šç·£æ‰£è¡€
    function checkEdgeDamage() {
        const xAbs = Math.abs(cube.position.x);
        const zAbs = Math.abs(cube.position.z);
        inEdgeZone = (xAbs > SAFE_ZONE || zAbs > SAFE_ZONE);
        if (inEdgeZone) {
            stopRecover();
            leftEdgeTime = Date.now();
            startDamage();
        } else {
            stopDamage();
            if (Date.now() - leftEdgeTime > 2000) {
                startRecover();
            }
        }
    }

    // æ›´æ–°ç«‹æ–¹é«”ä½ç½®
    function updateCubePositionAndRotation() {
        keyDx = 0;
        keyDz = 0;
        if (keys.ArrowLeft) keyDx = -maxSpeed;
        if (keys.ArrowRight) keyDx = maxSpeed;
        if (keys.ArrowUp) keyDz = -maxSpeed;
        if (keys.ArrowDown) keyDz = maxSpeed;

        cube.position.x += dx + keyDx;
        cube.position.z += dz + keyDz;
        cubeHitbox.position.copy(cube.position);

        // é‚Šç•Œæª¢æŸ¥
        if (cube.position.x < -MAX_ZONE) cube.position.x = -MAX_ZONE;
        if (cube.position.x > MAX_ZONE) cube.position.x = MAX_ZONE;
        if (cube.position.z < -MAX_ZONE) cube.position.z = -MAX_ZONE;
        if (cube.position.z > MAX_ZONE) cube.position.z = MAX_ZONE;

        camera.position.x = cube.position.x;
        camera.position.y = 8;
        camera.position.z = cube.position.z + 6;
        camera.lookAt(cube.position.x, 0, cube.position.z);
    }

    // ä¸‰è§’éŒ
    function createObstacle() {
        if (gameRunning && !gameOver) {
            const geometry = new THREE.ConeGeometry(0.5, 1, 3);
            const material = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            const cone = new THREE.Mesh(geometry, material);
            cone.castShadow = true;
            cone.receiveShadow = true;
            cone.scale.set(OBJECT_SCALE, OBJECT_SCALE, OBJECT_SCALE);
            const direction = Math.floor(Math.random() * 4);
            cone.userData = { dx: 0, dz: 0 };
            const rand = Math.random() * 4 - 2; // èª¿æ•´éš¨æ©Ÿç¯„åœ
            switch (direction) {
                case 0: cone.position.set(-GENERATE_EDGE, 0, rand); cone.userData.dx = coneSpeed; break;
                case 1: cone.position.set(GENERATE_EDGE, 0, rand); cone.userData.dx = -coneSpeed; break;
                case 2: cone.position.set(rand, 0, GENERATE_EDGE); cone.userData.dz = -coneSpeed; break;
                case 3: cone.position.set(rand, 0, -GENERATE_EDGE); cone.userData.dz = coneSpeed; break;
            }
            scene.add(cone);
            obstacles.push(cone);
            createConeHitbox(cone);
        }
    }

    function updateObstacles() {
        obstacles.forEach((obs, index) => {
            obs.position.x += obs.userData.dx;
            obs.position.z += obs.userData.dz;
            obs.rotation.y += 0.02;
            
            if (obstacleHitboxes[index]) {
                obstacleHitboxes[index].position.copy(obs.position);
                obstacleHitboxes[index].rotation.copy(obs.rotation);
            }
            
            const cubeHitboxBox = new THREE.Box3().setFromObject(cubeHitbox);
            const obsBox = new THREE.Box3().setFromObject(obs);
            if (cubeHitboxBox.intersectsBox(obsBox)) {
                endGame();
            }
            
            if (Math.abs(obs.position.x) > GENERATE_EDGE || Math.abs(obs.position.z) > GENERATE_EDGE) {
                removeObstacle(obs, index, obstacleHitboxes, obstacles);
            }
        });
    }

    // çƒé«”
    function createSphereObstacle() {
        if (gameRunning && !gameOver) {
            const direction = Math.floor(Math.random() * 4);
            let startPos = new THREE.Vector3();
            let endPos = new THREE.Vector3();
            let sphereDx = 0, sphereDz = 0;
            const rand = Math.random() * 4 - 2; // èª¿æ•´éš¨æ©Ÿç¯„åœ
            switch (direction) {
                case 0: startPos.set(-GENERATE_EDGE, 0, rand); endPos.set(GENERATE_EDGE, 0, startPos.z); sphereDx = sphereSpeed; break;
                case 1: startPos.set(GENERATE_EDGE, 0, rand); endPos.set(-GENERATE_EDGE, 0, startPos.z); sphereDx = -sphereSpeed; break;
                case 2: startPos.set(rand, 0, GENERATE_EDGE); endPos.set(startPos.x, 0, -GENERATE_EDGE); sphereDz = -sphereSpeed; break;
                case 3: startPos.set(rand, 0, -GENERATE_EDGE); endPos.set(startPos.x, 0, GENERATE_EDGE); sphereDz = sphereSpeed; break;
            }

            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const points = [startPos, endPos];
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
            lines.push(line);

            setTimeout(() => {
                scene.remove(line);
                lines.splice(lines.indexOf(line), 1);

                const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                const material = new THREE.MeshStandardMaterial({ color: 0xffa500 });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                sphere.position.copy(startPos);
                sphere.scale.set(OBJECT_SCALE, OBJECT_SCALE, OBJECT_SCALE);
                sphere.userData = { dx: sphereDx, dz: sphereDz };
                scene.add(sphere);
                sphereObstacles.push(sphere);
                createSphereHitbox(sphere);
            }, 1500);
        }
    }

    function updateSphereObstacles() {
        sphereObstacles.forEach((obs, index) => {
            obs.position.x += obs.userData.dx;
            obs.position.z += obs.userData.dz;
            
            if (sphereHitboxes[index]) {
                sphereHitboxes[index].position.copy(obs.position);
            }
            
            const cubeHitboxBox = new THREE.Box3().setFromObject(cubeHitbox);
            const obsBox = new THREE.Box3().setFromObject(obs);
            if (cubeHitboxBox.intersectsBox(obsBox)) {
                endGame();
            }
            
            if (Math.abs(obs.position.x) > GENERATE_EDGE || Math.abs(obs.position.z) > GENERATE_EDGE) {
                removeObstacle(obs, index, sphereHitboxes, sphereObstacles);
            }
        });
    }

    // é»ƒè‰²è®Šæ©™è‰²éšœç¤™ç‰©
    function createYellowObstacle() {
        if (gameRunning && !gameOver) {
            const geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            const yellow = new THREE.Mesh(geometry, material);
            yellow.castShadow = true;
            yellow.receiveShadow = true;
            yellow.scale.set(OBJECT_SCALE, OBJECT_SCALE, OBJECT_SCALE);
            const direction = Math.floor(Math.random() * 4);
            yellow.userData = { dx: 0, dz: 0, activated: false };
            const rand = Math.random() * 4 - 2; // èª¿æ•´éš¨æ©Ÿç¯„åœ
            switch (direction) {
                case 0: yellow.position.set(-GENERATE_EDGE, 0, rand); yellow.userData.dx = yellowSpeed; break;
                case 1: yellow.position.set(GENERATE_EDGE, 0, rand); yellow.userData.dx = -yellowSpeed; break;
                case 2: yellow.position.set(rand, 0, GENERATE_EDGE); yellow.userData.dz = -yellowSpeed; break;
                case 3: yellow.position.set(rand, 0, -GENERATE_EDGE); yellow.userData.dz = yellowSpeed; break;
            }
            scene.add(yellow);
            yellowObstacles.push(yellow);
            createYellowHitbox(yellow);

            setTimeout(() => {
                if (yellowObstacles.includes(yellow)) {
                    yellow.material.color.set(0xffa500);
                    yellow.userData.dx = Math.sign(yellow.userData.dx) * 0.018;
                    yellow.userData.dz = Math.sign(yellow.userData.dz) * 0.018;
                    yellow.userData.dx *= 1.25;
                    yellow.userData.dz *= 1.25;
                    yellow.userData.activated = true;
                    if (yellowHitboxes[yellowObstacles.indexOf(yellow)]) {
                        yellowHitboxes[yellowObstacles.indexOf(yellow)].material.color.set(0xffa500);
                    }
                }
            }, 500);
        }
    }

    function updateYellowObstacles() {
        yellowObstacles.forEach((obs, index) => {
            obs.position.x += obs.userData.dx;
            obs.position.z += obs.userData.dz;
            obs.rotation.y += 0.03;
            
            if (yellowHitboxes[index]) {
                yellowHitboxes[index].position.copy(obs.position);
                yellowHitboxes[index].rotation.copy(obs.rotation);
            }
            
            const cubeHitboxBox = new THREE.Box3().setFromObject(cubeHitbox);
            const obsBox = new THREE.Box3().setFromObject(obs);
            if (cubeHitboxBox.intersectsBox(obsBox)) {
                endGame();
            }
            
            if (Math.abs(obs.position.x) > GENERATE_EDGE || Math.abs(obs.position.z) > GENERATE_EDGE) {
                removeObstacle(obs, index, yellowHitboxes, yellowObstacles);
            }
        });
    }

    // çµ±ä¸€ç§»é™¤å‡½æ•¸
    function removeObstacle(obs, index, hitboxArray, objArray) {
        scene.remove(obs);
        if (hitboxArray[index]) scene.remove(hitboxArray[index]);
        objArray.splice(index, 1);
        hitboxArray.splice(index, 1);
        score++;
        scoreEl.textContent = `åˆ†æ•¸: ${score}`;
    }

    function endGame(msg = 'éŠæˆ²çµæŸï¼') {
        gameOver = true;
        gameRunning = false;
        statusEl.textContent = `${msg} æœ€çµ‚åˆ†æ•¸: ${score}`;
        gameOverEl.style.display = 'block';
        stopDamage();
        stopRecover();
    }

    // é€£æ¥ micro:bit
    async function connectMicrobit() {
        try {
            statusEl.textContent = 'æœå°‹ micro:bit...';
            device = await navigator.bluetooth.requestDevice({
                filters: [{ namePrefix: 'BBC micro:bit' }],
                optionalServices: [UART_SERVICE_UUID]
            });
            server = await device.gatt.connect();
            service = await server.getPrimaryService(UART_SERVICE_UUID);
            txCharacteristic = await service.getCharacteristic(UART_TX_CHARACTERISTIC_UUID);
            await txCharacteristic.startNotifications();
            txCharacteristic.addEventListener('characteristicvaluechanged', handleReceivedData);
            rxCharacteristic = await service.getCharacteristic(UART_RX_CHARACTERISTIC_UUID);
            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            statusEl.textContent = 'å·²é€£æ¥ micro:bit';
        } catch (error) {
            statusEl.textContent = `é€£æ¥å¤±æ•—: ${error.message}`;
            console.error('Bluetooth é€£æ¥éŒ¯èª¤:', error);
        }
    }

    // æ–·é–‹é€£æ¥
    function disconnectMicrobit() {
        if (device && device.gatt.connected) {
            device.gatt.disconnect();
            statusEl.textContent = 'å·²æ–·é–‹é€£æ¥';
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
        }
    }

    // è™•ç†æ¥æ”¶æ•¸æ“šï¼ˆmicro:bitï¼‰
    function handleReceivedData(event) {
        let receivedData = new Uint8Array(event.target.value.buffer);
        let receivedString = new TextDecoder().decode(receivedData).trim();
        if (receivedString.includes('+')) {
            let [xStr, yStr] = receivedString.split('+');
            let x = parseInt(xStr);
            let y = parseInt(yStr);
            if (!isNaN(x) && !isNaN(y)) {
                statusEl.textContent = `æ”¶åˆ°åº§æ¨™: X=${x}, Y=${y}`;
                dx = (Math.abs(x) < 100) ? 0 : (x / 1024) * maxSpeed;
                dz = (Math.abs(y) < 100) ? 0 : (y / 1024) * maxSpeed;
            }
        }
    }

    // é‡ç½®éŠæˆ²
    function resetGame() {
        gameRunning = true;
        gameOver = false;
        gameOverEl.style.display = 'none';
        score = 0;
        hp = maxHp;
        scoreEl.textContent = `åˆ†æ•¸: ${score}`;
        updateHp();
        stopDamage();
        stopRecover();
        leftEdgeTime = 0;
        inEdgeZone = false;
        
        [obstacles, sphereObstacles, yellowObstacles].forEach(arr => arr.forEach(o => scene.remove(o)));
        [obstacleHitboxes, sphereHitboxes, yellowHitboxes].forEach(arr => arr.forEach(h => scene.remove(h)));
        lines.forEach(l => scene.remove(l));
        
        obstacles = sphereObstacles = yellowObstacles = [];
        obstacleHitboxes = sphereHitboxes = yellowHitboxes = [];
        lines = [];
        
        cube.position.set(0, 0, 0);
        cubeHitbox.position.copy(cube.position);
        
        statusEl.textContent = 'éŠæˆ²é–‹å§‹ï¼å‚¾æ–œ micro:bit æˆ–ä½¿ç”¨éµç›¤ä¸Šä¸‹å·¦å³æ§åˆ¶ç«‹æ–¹é«”';
    }

    // éµç›¤äº‹ä»¶ç›£è½
    document.addEventListener('keydown', (event) => {
        if (event.code in keys) keys[event.code] = true;
    });

    document.addEventListener('keyup', (event) => {
        if (event.code in keys) keys[event.code] = false;
    });

    // å•Ÿå‹•
    if (typeof THREE === 'undefined') {
        console.error('Three.js æœªè¼‰å…¥');
        statusEl.textContent = 'éŒ¯èª¤ï¼šThree.js æœªè¼‰å…¥';
    } else {
        console.log('Three.js å·²è¼‰å…¥');
        init3D();
    }

    // å®šæ™‚ç”Ÿæˆéšœç¤™ç‰©
    setInterval(createObstacle, 1000);
    setInterval(createSphereObstacle, 5000);
    setInterval(createYellowObstacle, 3000);

    // æŒ‰éˆ•äº‹ä»¶
    startBtn.addEventListener('click', resetGame);
    connectBtn.addEventListener('click', connectMicrobit);
    disconnectBtn.addEventListener('click', disconnectMicrobit);
    </script>
</body>
</html>