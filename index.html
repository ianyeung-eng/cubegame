<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>é›™æ‰‹å•Ÿå‹•ï¼é›™çƒæŒ‘æˆ°æ‰‹æ‰éŠæˆ²ï¼ˆé»ƒçƒä»»æ„åŒæ™‚è§¸ç¢°ç‰ˆï¼‰</title>
  <style>
    body { margin:0; background:#000; overflow:hidden; font-family:Arial, sans-serif; }
    #container { position: relative; width: 100vw; height: 100vh; }
    #video, #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    #canvas { pointer-events: none; }

    /* é¡é ­åè½‰æŒ‰éˆ• */
    #flipBtn {
      position: absolute;
      top: 20px; left: 20px;
      padding: 12px 20px;
      background: rgba(255,255,255,0.9);
      color: #000;
      border: none;
      border-radius: 50px;
      font-size: 16px;
      font-weight: bold;
      z-index: 100;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    #flipBtn:hover { background: #fff; }

    /* åˆ†æ•¸ */
    #ui {
      position: absolute;
      top: 20px; right: 20px;
      color: white;
      font-size: 36px;
      font-weight: bold;
      background: rgba(0,0,0,0.6);
      padding: 12px 30px;
      border-radius: 20px;
      z-index: 50;
      backdrop-filter: blur(8px);
    }

    /* é–‹å ´é›™ç´…çƒæç¤º */
    #readyText {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 32px;
      text-align: center;
      background: rgba(0,0,0,0.7);
      padding: 20px 40px;
      border-radius: 20px;
      z-index: 90;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="container">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <!-- é¡é ­åè½‰æŒ‰éˆ• -->
  <button id="flipBtn">ğŸ”„ é¡é ­åè½‰ï¼šé—œ</button>

  <!-- åˆ†æ•¸ï¼ˆéŠæˆ²é–‹å§‹å¾Œæ‰é¡¯ç¤ºï¼‰ -->
  <div id="ui" style="display:none;">åˆ†æ•¸ï¼š<span id="score">0</span></div>

  <!-- é›™æ‰‹å•Ÿå‹•æç¤º -->
  <div id="readyText">è«‹ç”¨<br><b>å·¦æ‰‹ç¢°å·¦é‚Šç´…çƒ</b>ï¼‹<b>å³æ‰‹ç¢°å³é‚Šç´…çƒ</b><br>åŒæ™‚å•Ÿå‹•éŠæˆ²ï¼</div>
</div>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const flipBtn = document.getElementById('flipBtn');
const ui = document.getElementById('ui');
const scoreEl = document.getElementById('score');
const readyText = document.getElementById('readyText');

let canvasWidth = window.innerWidth;
let canvasHeight = window.innerHeight;
canvas.width = canvasWidth;
canvas.height = canvasHeight;

let isMirrored = false;
let gameStarted = false;
let score = 0;

// é›™ç´…çƒï¼ˆå•Ÿå‹•ç”¨ï¼‰
let startLeftX = canvasWidth * 0.25;
let startRightX = canvasWidth * 0.75;
const startBalls = [
  { x: startLeftX, y: canvasHeight / 2, radius: 90, touched: false },
  { x: startRightX, y: canvasHeight / 2, radius: 90, touched: false }
];

// é›™é»ƒçƒç³»çµ±
let targets = [];
let isDoubleMode = false;

const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({
  modelComplexity: 1,
  smoothLandmarks: true,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});
pose.onResults(onResults);

// ç«‹å³é–‹å•Ÿé¡é ­
const camera = new Camera(video, {
  onFrame: async () => {
    await pose.send({image: video});
  },
  width: 1280,
  height: 720
});
camera.start();

// é¡é ­åè½‰æŒ‰éˆ•
flipBtn.addEventListener('click', () => {
  isMirrored = !isMirrored;
  flipBtn.textContent = `ğŸ”„ é¡é ­åè½‰ï¼š${isMirrored ? 'é–‹' : 'é—œ'}`;
  flipBtn.style.background = isMirrored ? '#00ff88' : 'rgba(255,255,255,0.9)';
});

function getDisplayX(rawX) {
  return isMirrored ? canvasWidth - rawX : rawX;
}

function checkHandTouch(landmarks, ballX, ballY) {
  const fingers = [15, 17, 19, 16, 18, 20];  // æ‰€æœ‰æ‰‹æŒ‡å°–
  for (let i of fingers) {
    const p = landmarks[i];
    if (!p || p.visibility < 0.3) continue;
    const px = getDisplayX(p.x * canvasWidth);
    const py = p.y * canvasHeight;
    if (Math.hypot(px - ballX, py - ballY) < 120) {
      return true;
    }
  }
  return false;
}

function checkSingleTouch(landmarks) {
  if (targets.length !== 1) return false;
  return checkHandTouch(landmarks, targets[0].displayX, targets[0].y);
}

function spawnTargets() {
  targets = [];
  if (Math.random() < 0.3) {  // 30% é›™é»ƒçƒ
    isDoubleMode = true;
    const ball1 = {
      x: 120 + Math.random() * (canvasWidth * 0.3),  // å·¦å´
      y: 120 + Math.random() * (canvasHeight - 240),
      displayX: 0,
      radius: 75,
      active: true,
      touched: false
    };
    const ball2 = {
      x: canvasWidth * 0.6 + Math.random() * (canvasWidth * 0.3),  // å³å´
      y: 120 + Math.random() * (canvasHeight - 240),
      displayX: 0,
      radius: 75,
      active: true,
      touched: false
    };
    ball1.displayX = getDisplayX(ball1.x);
    ball2.displayX = getDisplayX(ball2.x);
    targets.push(ball1, ball2);
  } else {  // å–®ç¶ çƒ
    isDoubleMode = false;
    const ball = {
      x: 80 + Math.random() * (canvasWidth - 160),
      y: 80 + Math.random() * (canvasHeight - 160),
      displayX: 0,
      radius: 80,
      active: true,
      touched: false
    };
    ball.displayX = getDisplayX(ball.x);
    targets.push(ball);
  }
}

function onResults(results) {
  ctx.save();
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  if (isMirrored) {
    ctx.scale(-1, 1);
    ctx.drawImage(results.image, -canvasWidth, 0, canvasWidth, canvasHeight);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  } else {
    ctx.drawImage(results.image, 0, 0, canvasWidth, canvasHeight);
  }

  if (results.poseLandmarks) {
    const lm = results.poseLandmarks;
    const displayLandmarks = isMirrored ? lm.map(p => ({...p, x: 1 - p.x})) : lm;
    drawConnectors(ctx, displayLandmarks, POSE_CONNECTIONS, {color: '#00FFFF', lineWidth: 3});
    drawLandmarks(ctx, displayLandmarks, {color: '#FF00FF', radius: 5});

    if (!gameStarted) {
      // å•Ÿå‹•éšæ®µï¼ˆç´…çƒï¼‰
      const leftTouch = checkHandTouch(lm, startBalls[0].x, startBalls[0].y);  // ç´…çƒä¸åˆ†å·¦å³æ‰‹
      const rightTouch = checkHandTouch(lm, startBalls[1].x, startBalls[1].y);
      startBalls[0].touched = leftTouch;
      startBalls[1].touched = rightTouch;

      startBalls.forEach(ball => {
        const displayBallX = getDisplayX(ball.x);
        ctx.fillStyle = ball.touched ? '#ff00ff' : '#ff4444';
        ctx.shadowBlur = 30;
        ctx.shadowColor = ball.touched ? '#ff00ff' : '#ff0000';
        ctx.beginPath();
        ctx.arc(displayBallX, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 8;
        ctx.stroke();
      });

      if (leftTouch && rightTouch) {
        gameStarted = true;
        readyText.style.display = 'none';
        ui.style.display = 'block';
        score = 0;
        scoreEl.textContent = '0';
        spawnTargets();
      }
    } else {
      // éŠæˆ²éšæ®µ
      let scored = false;

      if (isDoubleMode) {
        // ğŸ”¥ é»ƒçƒï¼šä»»æ„æ‰‹åŒæ™‚è§¸ç¢°å…©å€‹çƒ
        const touch1 = checkHandTouch(lm, targets[0].displayX, targets[0].y);
        const touch2 = checkHandTouch(lm, targets[1].displayX, targets[1].y);
        targets[0].touched = touch1;
        targets[1].touched = touch2;

        if (touch1 && touch2) {
          score += 2;
          scored = true;
        }
      } else if (checkSingleTouch(lm)) {
        targets[0].touched = true;
        score += 1;
        scored = true;
      }

      if (scored) {
        scoreEl.textContent = score;
        spawnTargets();

        scoreEl.style.transform = 'scale(2) rotate(360deg)';
        scoreEl.style.color = isDoubleMode ? '#ffd700' : '#00ff88';
        const addScore = isDoubleMode ? 2 : 1;
        scoreEl.innerHTML = `+${addScore}!`;
        setTimeout(() => {
          scoreEl.innerHTML = score;
          scoreEl.style.transform = 'scale(1) rotate(0deg)';
          scoreEl.style.color = 'white';
        }, 500);
      }

      // ç•«ç›®æ¨™çƒ
      targets.forEach((ball, index) => {
        if (!ball.active) return;

        const isYellow = isDoubleMode;
        const mainColor = isYellow ? (ball.touched ? '#ffff99' : '#ffff00') : '#00ff00';
        const glowColor = isYellow ? (ball.touched ? '#ffff00' : '#ffd700') : '#00ff00';
        const borderColor = isYellow ? '#ffaa00' : '#00ff88';

        ctx.fillStyle = mainColor;
        ctx.shadowBlur = 60;
        ctx.shadowColor = glowColor;
        ctx.beginPath();
        ctx.arc(ball.displayX, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.lineWidth = 18;
        ctx.strokeStyle = borderColor;
        ctx.stroke();
        ctx.shadowBlur = 0;

        const pulse = Math.sin(Date.now() * 0.015 + index) * 8 + ball.radius;
        ctx.beginPath();
        ctx.arc(ball.displayX, ball.y, pulse, 0, Math.PI * 2);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 4;
        ctx.stroke();

        if (isYellow) {
          ctx.fillStyle = '#ff0000';
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('é›™', ball.displayX, ball.y);  // åªæ¨™è¨˜ 'é›™' ä¸åˆ†å·¦å³
        }
      });
    }
  }
  ctx.restore();
}

// è¦–çª—èª¿æ•´
window.addEventListener('resize', () => {
  canvasWidth = window.innerWidth;
  canvasHeight = window.innerHeight;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  startLeftX = canvasWidth * 0.25;
  startRightX = canvasWidth * 0.75;
  startBalls[0].x = startLeftX;
  startBalls[1].x = startRightX;
  startBalls[0].y = canvasHeight / 2;
  startBalls[1].y = canvasHeight / 2;

  if (gameStarted) spawnTargets();
});
</script>

</body>
</html>